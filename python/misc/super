When calling `super()` to resolve to a parent's version of a classmethod, instance method, or staticmethod, we want to pass the current class whose scope we are in as the first argument, to indicate which parent's scope we're trying to resolve to, and as a second argument the object of interest to indicate which object we're trying to apply that scope to.

Consider a class hierarchy `A`, `B`, and `C` where each class is the parent of the one following it, and `a`, `b`, and `c` are respective instances of each.

    super(B, b) 
    # resolves to the scope of B's parent i.e. A 
    # and applies that scope to b, as if b was an instance of A

    super(C, c) 
    # resolves to the scope of C's parent i.e. B
    # and applies that scope to c

    super(B, c) 
    # resolves to the scope of B's parent i.e. A 
    # and applies that scope to c



Using `super` with a staticmethod
----------------------------------

e.g. using `super()` from within the `__new__()` method

    class A(object):
        def __new__(cls, *a, **kw):
            # ...
            # whatever you want to specialize or override here
            # ...
            
            return super(A, cls).__new__(cls, *a, **kw)

Explanation: 

1- even though it's usual for `__new__()` to take as its first param a reference to the calling class, it is *not* implemented in Python as a classmethod, but rather a staticmethod. That is, a reference to a class has to be passed explicitly as the first argument when calling `__new__()` directly:

    # if you defined this
    class A(object):
        def __new__(cls):
            pass

    # calling this would raise a TypeError due to the missing argument
    A.__new__()

    # whereas this would be fine
    A.__new__(A)

2- when calling `super()` to get to the parent class we pass the child class `A` as its first argument, then we pass a reference to the object of interest, in this case it's the class reference that was passed when `A.__new__(cls)` was called. In most cases it also happens to be a reference to the child class. In some situations it might not be, for instance in the case of multiple generation inheritances.

    super(A, cls)

3- since as a general rule `__new__()` is a staticmethod, `super(A, cls).__new__` will also return a staticmethod and needs to be supplied all arguments explicitly, including the reference to the object of insterest, in this case `cls`.

    super(A, cls).__new__(cls, *a, **kw)

4- doing the same thing without `super`

    class A(object):
        def __new__(cls, *a, **kw):
            # ...
            # whatever you want to specialize or override here
            # ...
            
            return object.__new__(cls, *a, **kw)
    

Using `super` with an instance method
-------------------------------------

e.g. using `super()` from within `__init__()`

    class A(object): 
        def __init__(self, *a, **kw):
            # ...
            # you make some changes here
            # ...

            super(A, self).__init__(*a, **kw)

Explanation:

1- `__init__` is an instance method, meaning that it takes as its first argument a reference to an instance. When being called directly from the instance, the reference is passed implicitly, that is you don't need to specify it:


    # you try calling `__init__()` from the class without specifying an instance
    # and a TypeError is raised due to the expected but missing reference
    A.__init__() # TypeError ...

    # you create an instance
    a = A()

    # you call `__init__()` from that instance and it works
    a.__init__()

    # you can also call `__init__()` with the class and explicitly pass the instance 
    A.__init__(a)

2- when calling `super()` within `__init__()` we pass the child class as the first argument and the object of interest as a second argument, which in general is a reference to an instance of the child class.

    super(A, self)


3- The call `super(A, self)` resolves to a proxy that acts as if `self` is now an instance of the parent class. Let's call that proxy `s`. Since `__init__()` is an instance method the call `s.__init__(...)` will implicitly pass a reference of `self` as the first argument to the parent's `__init__()`

4- to do the same without `super` we need to pass a reference to an instance explicitly 

    class A(object): 
        def __init__(self, *a, **kw):
            # ...
            # you make some changes here
            # ...

            object.__init__(self, *a, **kw)


Using `super` with a classmethod
--------------------------------

    class A(object):
        @classmethod
        def alternate_constructor(cls, *a, **kw):
            print "A.alternate_constructor called"
            return cls(*a, **kw)
            
    class B(A):
        @classmethod
        def alternate_constructor(cls, *a, **kw):
            # ...
            # whatever you want to specialize or override here
            # ...

            print "B.alternate_constructor called"
            return super(B, cls).alternate_constructor(*a, **kw)

Explanation:

1- A classmethod can be called from the class directly and takes as its first parameter a reference to the class. 
    
    # calling directly from the class is fine,
    # a reference to the class is passed implicitly
    a = A.alternate_constructor()
    b = B.alternate_constructor()

2- when calling `super()` within a classmethod to resolve to its parent's version of it, we want to pass the current child class as the first argument to indicate which parent's scope we're trying to resolve to, and the object of interest as the second argument to indicate which object we want to apply that scope to, which in general is a reference to the child class itself or one of its subclasses.

    super(B, cls_or_subcls)

3- The call `super(B, cls)` resolves to the scope of `A` and applies it to `cls`. Since `alternate_constructor()` is a classmethod the call `super(B, cls).alternate_constructor(...)` will implicitly pass a reference of `cls` as the first argument to `A`'s version of `alternate_constructor()`

    super(B, cls).alternate_constructor()

4- to do the same without using `super()` you would need to get a reference to the *unbound* version of `A.alternate_constructor()` (i.e. the explicit version of the function). Simply doing this would not work:

    class B(A):
        @classmethod
        def alternate_constructor(cls, *a, **kw):
            # ...
            # whatever you want to specialize or override here
            # ...

            print "B.alternate_constructor called"
            return A.alternate_constructor(cls, *a, **kw)

The above would not work because the `A.alternate_constructor()` method takes an implicit reference to `A` as its first argument. The `cls` being passed here would be its second argument.

    class B(A):
        @classmethod
        def alternate_constructor(cls, *a, **kw):
            # ...
            # whatever you want to specialize or override here
            # ...

            print "B.alternate_constructor called"
            # first we get a reference to the unbound `A.alternate_constructor` function 
            unbound_func = A.alternate_constructor.im_func
            # now we call it and pass our own `cls` as its first argument
            return unbound_func(cls, *a, **kw)

