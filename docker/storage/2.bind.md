### Ref: https://docs.docker.com/storage/bind-mounts/

---

- have limited functionality compared to volumes.
- named volume are recommended for new Docker applications.

- can be file or directory on the host system.
- may be stored anywhere on the host system, even important system files or directories.
- non-docker processes may modify them at any time.
- referenced by its full path on the host machine.
- does not need to already exist on the host. Created on demand.
- fast but demand that the host machine's filesystem has a specific directory structure available.
- cannot be managed using Docker CLI commands.

### Good use cases
- sharing config from the host machine to containers. E.g. this is how docker provides DNS resolution to containers by default, by mounting `/etc/resolv.conf` from the host machine into container.
- sharing source code or build artifacts between development environment on the docker host and container. E.g. mouting a Maven's `target/` directory into a container, such that each time the project is built on the host, the container gets access to the rebuit artifacts. Using docker for development this way, the production Dockerfile would copy the production-ready artifacts directly into the image, rather than relying on a bind mount.
- when the file or directory structure of the docker hosts is guaranteed to be consistent with the bind mounts the containers require.


### Tips
- if you mount a bind mount or non-empty volume into a directory in the container in which some files or directories exist, these files or directories are obscured by the mount, just as if you saved the files into `/mnt` on a Linux host and then mounted a USB drive into `/mnt`. The contents of `/mnt` would be obscured by the contents of the USB drive until it's unmounted. The obscured files are not removed or altered, but are not accessible while the bind mount or volume is mounted.
